 <!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <title>Game Karambol</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    canvas {
      background: #3e2723;
      border: 10px solid #8d6e63;
      border-radius: 10px;
      box-shadow: 0 0 20px black;
    }
  </style>
</head>
<body>
<canvas id="board" width="600" height="600"></canvas>

<script>
const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");

const WIDTH = canvas.width;
const HEIGHT = canvas.height;

const friction = 0.985;
const radius = 10;
const strikerRadius = 12;
const holes = [
  {x: 0, y: 0},
  {x: WIDTH, y: 0},
  {x: 0, y: HEIGHT},
  {x: WIDTH, y: HEIGHT}
];

const coins = [];
let striker;

function resetStriker() {
  const index = coins.findIndex(b => b.isStriker);
  if (index !== -1) coins.splice(index, 1);

  striker = new Ball(WIDTH / 2, HEIGHT - 50, "white", true);
  coins.unshift(striker);
}

class Ball {
  constructor(x, y, color, isStriker = false) {
    this.x = x;
    this.y = y;
    this.vx = 0;
    this.vy = 0;
    this.color = color;
    this.radius = isStriker ? strikerRadius : radius;
    this.isStriker = isStriker;
    this.removed = false;
  }

  draw() {
    if (this.removed) return;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fillStyle = this.color;
    ctx.fill();
    ctx.closePath();
  }

  move() {
    if (this.removed) return;

    this.x += this.vx;
    this.y += this.vy;
    this.vx *= friction;
    this.vy *= friction;

    if (this.x - this.radius <= 0 || this.x + this.radius >= WIDTH) {
      this.vx *= -1;
      this.x = Math.max(this.radius, Math.min(this.x, WIDTH - this.radius));
    }
    if (this.y - this.radius <= 0 || this.y + this.radius >= HEIGHT) {
      this.vy *= -1;
      this.y = Math.max(this.radius, Math.min(this.y, HEIGHT - this.radius));
    }

    for (let hole of holes) {
      const dx = hole.x - this.x;
      const dy = hole.y - this.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 18) {
        this.removed = true;
      }
    }
  }
}

// Tambah coin
const colors = ["red", "black", "yellow"];
for (let i = 0; i < 6; i++) {
  const angle = (i / 6) * Math.PI * 2;
  const x = WIDTH / 2 + Math.cos(angle) * 30;
  const y = HEIGHT / 2 + Math.sin(angle) * 30;
  coins.push(new Ball(x, y, colors[i % colors.length]));
}

resetStriker();

function handleCollisions() {
  for (let i = 0; i < coins.length; i++) {
    for (let j = i + 1; j < coins.length; j++) {
      const a = coins[i];
      const b = coins[j];
      if (a.removed || b.removed) continue;

      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const minDist = a.radius + b.radius;

      if (dist < minDist) {
        const nx = dx / dist;
        const ny = dy / dist;
        const p = 2 * (a.vx * nx + a.vy * ny - b.vx * nx - b.vy * ny) / 2;

        a.vx -= p * nx;
        a.vy -= p * ny;
        b.vx += p * nx;
        b.vy += p * ny;

        const overlap = minDist - dist;
        a.x -= nx * overlap / 2;
        a.y -= ny * overlap / 2;
        b.x += nx * overlap / 2;
        b.y += ny * overlap / 2;
      }
    }
  }
}

function drawHoles() {
  for (let hole of holes) {
    ctx.beginPath();
    ctx.arc(hole.x, hole.y, 18, 0, Math.PI * 2);
    ctx.fillStyle = "black";
    ctx.fill();
    ctx.closePath();
  }
}

function drawAimLine() {
  if (aiming && !striker.removed && allBallsStopped()) {
    ctx.setLineDash([5, 5]);
    ctx.strokeStyle = "white";
    ctx.beginPath();
    ctx.moveTo(striker.x, striker.y);
    ctx.lineTo(mouseX, mouseY);
    ctx.stroke();
    ctx.setLineDash([]);
  }
}

function allBallsStopped() {
  return coins.every(ball =>
    ball.removed || (Math.abs(ball.vx) < 0.1 && Math.abs(ball.vy) < 0.1)
  );
}

function draw() {
  ctx.clearRect(0, 0, WIDTH, HEIGHT);
  drawHoles();

  for (let ball of coins) {
    ball.move();
    ball.draw();
  }

  handleCollisions();
  drawAimLine();

  if (striker.removed && allBallsStopped()) {
    resetStriker();
  }

  requestAnimationFrame(draw);
}

draw();

// Kontrol mouse
let aiming = false;
let mouseX = 0;
let mouseY = 0;

canvas.addEventListener("mousedown", (e) => {
  if (striker.removed || !allBallsStopped()) return;
  aiming = true;
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = e.clientY - rect.top;
});

canvas.addEventListener("mousemove", (e) => {
  if (!aiming || striker.removed) return;
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = e.clientY - rect.top;
});

canvas.addEventListener("mouseup", (e) => {
  if (!aiming || striker.removed) return;
  const rect = canvas.getBoundingClientRect();
  const dx = (e.clientX - rect.left) - striker.x;
  const dy = (e.clientY - rect.top) - striker.y;

  const len = Math.sqrt(dx * dx + dy * dy);
  if (len < 5) {
    aiming = false;
    return;
  }

  const maxSpeed = 10;
  const factor = Math.min(0.05, maxSpeed / len);
  striker.vx = dx * factor;
  striker.vy = dy * factor;

  aiming = false;
});
</script>
</body>
</html>
